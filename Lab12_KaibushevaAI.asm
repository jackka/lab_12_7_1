;Лабораторная работа 12.Сравнение строк как массивов байтов
;Сравнить 2 строки Str1 и Str2 - массивы байтов в сегменте данных.
;Вывести результат на экран в виде целого числа
;0, если Str1=Str2
;1, Str1>Str2
;-1, Str1
;и сообщения "Строки равны", "1 строка больше" или "1 строка меньше"
;Признаком конца строки считать 0
;Исполнитель: Кайбушева А.И.

include console.inc

.data
str1 DB 80 DUP(?)
str2 DB 80 DUP(?)
Len  DD ?
N	DB ?

.code
start:
;вводим 1 строку, проверяем на длину и окончание ввода
	outstr 'Ввод первой строки не больше 80: '
	mov  N,0									;обнулили N
	lea ESI, str1								;загрузка адреса первого элемента str1 в ESI
    jmp L1 
L:	
	outchar AL									;вывод символа на экран с кодом ascii в AL
L1: 
	ReadKey										;чтение одного символа
	mov [ESI],AL								;в ячейки памяти начиная с адреса, хранящегося в ESI записать байт из AL
	inc ESI										;передвинулись на следующую ячейку									
	cmp N,80									;сравнили количество введенных символов N с 80
	inc N										;увеличили счетик N+1
	ja L2										;если длина строки больше 80, прекращаем чтением символов из str1
	cmp  AL,'0'									;если длина строки меньше 80, проверяем не введен ли 0 как признак конца строки
	jne  L										;если 0 не введен, возврат к началу цикла L
L2: 

;вводим 2 строку, проверяем на длину и окончание ввода 
  newline
  
	outstr 'Ввод второй строки не больше 80: '	
	mov  N,0									;обнулили N
	lea ESI, str2								;загрузка адреса первого элемента str2 в ESI
	jmp LL1
LL:	
	outchar AL									;вывод символа на экран с кодом ascii в AL
LL1:
	ReadKey										;чтение одного символа
	mov [ESI],AL								;в ячейки памяти начиная с адреса, хранящегося в ESI записать байт из AL
	inc ESI										;передвинулись на следующую ячейку в ESI
	cmp N,80									;сравнили количество введенных символов N с 80
	inc N										;увеличили счетик N+1
	ja LL2										;если длина строки больше 80, прекращаем чтением символов из str2
	cmp  AL,'0'									;если длина строки меньше 80, проверяем не введен ли 0 как признак конца строки
	jne  LL										;если 0 не введен, возврат к началу цикла LL
LL2:  

;подсчитываем длину строк   
newline

    lea ESI,str1								;загрузка адреса первого элемента str1 в ESI
    call StrLn									;вызов StrLn для подсчета длины 1 строки
    mov Len,EBX									;в Len загружаем длину 1 строки
    lea ESI,str2								;загрузка адреса первого элемента str2 в ESI
    call StrLn									;вызов StrLn для подсчета длины 2 строки
    mov ECX,EBX									;в ECX загружаем длину 2 строки
    cmp ECX,Len									;сравниваем, какая из двух строк длинее
    jb str_a									;если 2 строка меньше (ECX < Len), выводим "1 строка больше"
	ja str_b									;если 2 строка больше (ECX > Len), выводим "1 строка меньше"
goA:
    xor EBX,EBX									;очистка EBX
    lea ESI,str1								;загрузка адреса первого элемента str1 в ESI
    lea EDI,str2								;загрузка адреса первого элемента str2 в EDI
    cld											;установка флага DF=0			направление роста адресов
goB:
    lodsb										;загрузка байта в AL
    cmp AL,[EDI]								;сравнение символов первой и второй строк
    je goC										;символы равны, переход на goC
    jb goD										;символ в 1 строке меньше, переход на goD
    mov EBX,1									;символ в 1 строке больше, присвоим EBX значение 1 и переход на goE
    jmp goE

;если символ в 1 строке меньше
goD:    
    mov EBX,-1									;присвоили EBX значение -1 и переход на goE
    jmp goE										

;если символы равны
goC:    
    inc EDI										;передвинулись на следующую ячейку в EDI
    loop goB									;повтор цикла goB

;вывод в консоль значение EBX (1,-1 или 0) и сообщения о строках
goE:    
    outintln EBX								;вывод в консоль значение EBX
	cmp ebx,0									;сравнили EBX с 0
    jb str_b									;если EBX < 0, выводим сообщение "1 строка меньше"
	ja str_a									;если EBX > 0, выводим сообщение "1 строка больше"
	outstr "Строки равны"						;если EBX = 0, выводим сообщение "Строки равны"
	jmp fin

;вывод в консоль сообщения "1 строка меньше"
str_b:
	outstr "1 строка меньше"
	jmp fin

;вывод в консоль сообщения "1 строка меньше"
str_a:
	outstr "1 строка больше" 

fin:	
	newline
	pause "press any key to exit ..."
    exit
	
	;
;расчет длины строки
    StrLn proc									
        cld										;установка флага DF=0			направление роста адресов
        xor EBX,EBX								;очистка EBX
nextChar:        
        lodsb									;загрузка байта в AL
        or AL,AL								;проверка на ноль для определения конца строки
        jz return								;если 0 - достигнут конец строки, выход из процедуры
        inc EBX									;в EBX получим длину строки
        jmp nextChar							;снова повторяем процедуру
return:        
        ret	
    StrLn endp
	
end start    